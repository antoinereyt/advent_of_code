# AOC 2023 - Day 01

```elixir
Mix.install([
  {:smaoc, git: "https://github.com/nettinho/smaoc"}
])
```

## Section


```elixir
defmodule Smaoc.Solution do
  defp parse_input(input) do
    input |> String.split("\n", trim: true)
  end

  # Example
  # 
  # 1abc2
  # pqr3stu8vwx
  # a1b2c3d4e5f
  # treb7uchet
  # 
  # In this example, the calibration values of these four lines are 12, 38, 15, and 77.
  # Adding these together produces 142.
  def solve(:part1, input) do
    parse_input(input)
    |> Enum.map(fn line ->
      Regex.scan(~r/\d/, line)
    end)
    |> Enum.map(&List.flatten/1)
    |> Enum.map(fn numbers ->
      [
        numbers |> List.first(),
        numbers |> List.last()
      ]
    end)
    |> Enum.map(&Enum.join/1)
    |> Enum.map(&String.to_integer/1)
    |> Enum.sum()
    |> dbg()
  end

  # Example
  #
  # two1nine
  # eightwothree
  # abcone2threexyz
  # xtwone3four
  # 4nineeightseven2
  # zoneight234
  # 7pqrstsixteen
  #
  # In this example, the calibration values are 29, 83, 13, 24, 42, 14, and 76.
  # Adding these together produces 281.
  def solve(:part2, input) do
    digits = ~w(one two three four five six seven eight nine)
    r = ~r/(?=(\d|one|two|three|four|five|six|seven|eight|nine))/

    a_to_i =
      Enum.concat(
        digits |> Enum.with_index(1) |> Map.new(),
        1..9 |> Enum.map(&{"#{&1}", &1})
      )
      |> Map.new()

    parse_input(input)
    |> Enum.map(fn line ->
      Regex.scan(r, line, capture: :all_but_first)
    end)
    |> Enum.map(&List.flatten/1)
    |> Enum.map(fn numbers ->
      [
        numbers |> List.first(),
        numbers |> List.last()
      ]
    end)
    |> Enum.map(fn x ->
      x |> Enum.map(&a_to_i[&1])
    end)
    |> Enum.map(&Integer.undigits/1)
    |> Enum.sum()
    |> dbg()
  end
end

year = "2023"
day = "1"
run_config = ["example", "part1"]

inputs = %{
  "puzzle" => "",
  "example" => "1abc2\npqr3stu8vwx\na1b2c3d4e5f\ntreb7uchet"
}

response =
  for part <- ["part1", "part2"], input_key <- ["puzzle", "example"] do
    {part, input_key}
  end

response =
  response
  |> Enum.filter(fn {part, input_key} ->
    part in run_config and input_key in run_config
  end)
  |> Enum.map(fn {part, input_key} ->
    [part, input_key, Smaoc.Solution.solve(String.to_atom(part), inputs[input_key])]
  end)

Smaoc.Response.new(%{response: response, run_config: run_config, year: year, day: day})
```
